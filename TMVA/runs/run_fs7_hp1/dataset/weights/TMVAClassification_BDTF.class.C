// Class: ReadBDTF
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDTF
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.26/02       [399874]
Creator        : s1412595
Date           : Sun May  1 17:48:22 2022
Host           : Linux root-ubuntu-2004-1 5.4.0-73-generic #82-Ubuntu SMP Wed Apr 14 17:39:42 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/s1412595/Desktop/MSc/TMVA/runs/run_fs7_hp1
Training events: 120000
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "2.5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
SeparationType: "giniindex" [Separation criterion for node splitting]
UseFisherCuts: "True" [Use multivariate splits using the Fisher criterion]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for BoostType=Grad algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 11
Kbach_ProbNNk                 Kbach_ProbNNk                 Kbach_ProbNNk                 Kbach_ProbNNk                                                   'F'    [0.510000884533,0.999803304672]
Kbach_ProbNNp                 Kbach_ProbNNp                 Kbach_ProbNNp                 Kbach_ProbNNp                                                   'F'    [3.09430191692e-07,0.999382197857]
Kbach_PT                      Kbach_PT                      Kbach_PT                      Kbach_PT                                                        'F'    [403.433502197,14721.0791016]
Lc_PT                         Lc_PT                         Lc_PT                         Lc_PT                                                           'F'    [2527.61889648,40041.5273438]
Xicst_PT                      Xicst_PT                      Xicst_PT                      Xicst_PT                                                        'F'    [2326.83642578,49234.2539062]
pibach_ProbNNpi               pibach_ProbNNpi               pibach_ProbNNpi               pibach_ProbNNpi                                                 'F'    [0.100149095058,0.999639689922]
pibach_ProbNNp                pibach_ProbNNp                pibach_ProbNNp                pibach_ProbNNp                                                  'F'    [4.44849604264e-07,0.956227481365]
Xicst_IPCHI2_OWNPV            Xicst_IPCHI2_OWNPV            Xicst_IPCHI2_OWNPV            Xicst_IPCHI2_OWNPV                                              'F'    [1.3711878637e-05,26399.6132812]
Xicst_ENDVERTEX_CHI2          Xicst_ENDVERTEX_CHI2          Xicst_ENDVERTEX_CHI2          Xicst_ENDVERTEX_CHI2                                            'F'    [0.00172308029141,59.9373703003]
pibach_IPCHI2_OWNPV           pibach_IPCHI2_OWNPV           pibach_IPCHI2_OWNPV           pibach_IPCHI2_OWNPV                                             'F'    [8.96283199836e-06,8.99967575073]
Kbach_IPCHI2_OWNPV            Kbach_IPCHI2_OWNPV            Kbach_IPCHI2_OWNPV            Kbach_IPCHI2_OWNPV                                              'F'    [1.30371254272e-05,8.99991798401]
NSpec 1
Xicst_M                       Xicst_M                       Xicst_M                       Xicst Mass                    F                                 'F'    [2923.77636719,3907.79272461]


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#include <algorithm>
#include <limits>

#define NN new BDTFNode

#ifndef BDTFNode__def
#define BDTFNode__def

class BDTFNode {

public:

   // constructor of an essentially "empty" node floating in space
   BDTFNode ( BDTFNode* left,BDTFNode* right,
                          int nFisherCoeff,
                          double fisherCoeff0,
                          double fisherCoeff1,
                          double fisherCoeff2,
                          double fisherCoeff3,
                          double fisherCoeff4,
                          double fisherCoeff5,
                          double fisherCoeff6,
                          double fisherCoeff7,
                          double fisherCoeff8,
                          double fisherCoeff9,
                          double fisherCoeff10,
                          double fisherCoeff11,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fNFisherCoeff ( nFisherCoeff ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
     fFisherCoeff.push_back(fisherCoeff0);
     fFisherCoeff.push_back(fisherCoeff1);
     fFisherCoeff.push_back(fisherCoeff2);
     fFisherCoeff.push_back(fisherCoeff3);
     fFisherCoeff.push_back(fisherCoeff4);
     fFisherCoeff.push_back(fisherCoeff5);
     fFisherCoeff.push_back(fisherCoeff6);
     fFisherCoeff.push_back(fisherCoeff7);
     fFisherCoeff.push_back(fisherCoeff8);
     fFisherCoeff.push_back(fisherCoeff9);
     fFisherCoeff.push_back(fisherCoeff10);
     fFisherCoeff.push_back(fisherCoeff11);
   }

   virtual ~BDTFNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTFNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTFNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTFNode*   fLeft;     // pointer to the left daughter node
   BDTFNode*   fRight;    // pointer to the right daughter node
   int                     fNFisherCoeff; // =0 if this node doesn't use fisher, else =nvar+1 
   std::vector<double>     fFisherCoeff;  // the fisher coeff (offset at the last element)
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 

//_______________________________________________________________________
   BDTFNode::~BDTFNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 

//_______________________________________________________________________
bool BDTFNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
   if (fNFisherCoeff == 0){
     result = (inputValues[fSelector] >= fCutValue );
   }else{
     double fisher = fFisherCoeff.at(fFisherCoeff.size()-1);
     for (unsigned int ivar=0; ivar<fFisherCoeff.size()-1; ivar++)
       fisher += fFisherCoeff.at(ivar)*inputValues.at(ivar);
     result = fisher > fCutValue;
   }
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}

//_______________________________________________________________________
bool BDTFNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}

#endif

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDTF : public IClassifierReader {

 public:

   // constructor
   ReadBDTF( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadBDTF" ),
        fNvars( 11 )
   {
      // the training input variables
      const char* inputVars[] = { "Kbach_ProbNNk", "Kbach_ProbNNp", "Kbach_PT", "Lc_PT", "Xicst_PT", "pibach_ProbNNpi", "pibach_ProbNNp", "Xicst_IPCHI2_OWNPV", "Xicst_ENDVERTEX_CHI2", "pibach_IPCHI2_OWNPV", "Kbach_IPCHI2_OWNPV" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDTF() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[11];
   double fVmax[11];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[11];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTFNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDTF::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTFNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTFNode*)current->GetRight();
         else current=(BDTFNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
}

void ReadBDTF::Initialize()
{
  double inf = std::numeric_limits<double>::infinity();
  double nan = std::numeric_limits<double>::quiet_NaN();
  // itree = 0
  fBoostWeights.push_back(0.628328232745093);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 6146.9, 0, 1, 0.833474,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.621211,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.365668,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.929821, 0, 0, 0.504366,-99) , 
12, 0, 0, -0.000222712, -0.000363275, 0.000372268, 0, 0, 0, 0, 0, 0, -0.508626, 11, -0.0243725, 0, 0, 0.662963,-99) , 
NN(
0, 
0, 
12, 0, 0, 0, -0.000578132, 0.000540893, 0, 0, 0, 0, 0, 0, -0.340495, -1, -0.0532487, 0, -1, 0.0916474,-99) , 
12, 0, 0, -0.000642738, -0.000908995, 0.000885012, 0, 0, 0, 0, 0, 0, -0.579131, 11, -0.229713, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.524181);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.786438,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.398958,-99) , 
12, 0, 0, 0, 6.90081e-05, -1.74302e-05, 0, 0, 0, 0, 0, 0, -0.358937, 11, -0.121709, 0, 0, 0.72582,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.660176,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.225099,-99) , 
12, 0, 0, 0, -0.00109995, 0.000926669, 0, 0, 0, 0, 0, 0, -0.200559, 11, 0.0778197, 0, 0, 0.4155,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1085.24, 0, 0, 0.669858,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.50417,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.322811,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.956669, 0, 0, 0.390826,-99) , 
NN(
0, 
0, 
12, 0, 0, 0, -0.00118214, 0.00109103, 0, 0, 0, 0, 0, 0, -0.45873, -1, 0.0426207, 0, -1, 0.0966419,-99) , 
12, 0, 0, 0, -0.000473949, 0.000453259, 0, 0, 0, 0, 0, 0, -0.437846, 11, -0.0805893, 0, 0, 0.273859,-99) , 
12, 0, 0, -0.000580184, -0.000751754, 0.000732677, 0, 0, 0, 0, 0, 0, -0.419141, 11, -0.0618179, 0, 0, 0.483359,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.394509);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.686178,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.217628,-99) , 
12, 0, 0, -0.000323652, -0.000287688, 0.000307633, 0, 0, 0, 0, 0, 0, -0.297056, 11, -0.137178, 0, 0, 0.642275,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.505619,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.165417,-99) , 
12, 0, 0, 0, -0.000766258, 0.000651773, 0, 0, 0, 0, 0, 0, -0.203965, 11, -0.128102, 0, 0, 0.426307,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1085.24, 0, 0, 0.586398,-99) , 
NN(
0, 
0, 
12, 0, 0, 0, -0.000438982, 0.00041909, 0, 0, 0, 0, 0, 0, -0.370111, -1, -0.108036, 0, -1, 0.271838,-99) , 
12, 0, 0, -0.000519407, -0.000652189, 0.000631148, 0, 0, 0, 0, 0, 0, -0.300497, 11, -0.0911483, 0, 0, 0.476943,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.179466);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.953319, 0, 1, 0.71777,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.501275,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.343803,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 757.557, 0, 0, 0.474717,-99) , 
12, 0, 0, -9.69189e-05, -0.000151004, 0.000155281, 0, 0, 0, 0, 0, 0, -0.190624, 11, 0.0935245, 0, 0, 0.504266,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 771.908, 1, -1, 0.0360028,-99) , 
12, 0, 0, -0.000338823, -0.000429833, 0.000418686, 0, 0, 0, 0, 0, 0, -0.227122, 11, -0.147413, 0, 0, 0.460961,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.216703);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.750078,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.449907,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.953281, 0, 0, 0.659421,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.871141, 0, -1, 0.432782,-99) , 
12, 0, 0, -0.000170197, -0.000219872, 0.000219958, 0, 0, 0, 0, 0, 0, -0.177808, 11, 0.0875258, 0, 0, 0.46183,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1.28569, 1, -1, 0.00140344,-99) , 
12, 0, 0, -0.000336933, -0.000407256, 0.000397461, 0, 0, 0, 0, 0, 0, -0.200554, 11, -0.157371, 0, 0, 0.435498,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.175932);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.593584,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.474539,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.976479, 0, 0, 0.523358,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.883075, 0, -1, 0.269428,-99) , 
12, 0, 0, -0.000179971, -0.000222701, 0.000220835, 0, 0, 0, 0, 0, 0, -0.149565, 11, -0.0760845, 0, 0, 0.500469,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
12, 0, 0, -0.000326075, -0.000385271, 0.000375041, 0, 0, 0, 0, 0, 0, -0.16928, 11, -0.156234, 0, 0, 0.479897,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.186531);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
12, 0, 0, -8.65315e-06, -4.71303e-05, 5.11529e-05, 0, 0, 0, 0, 0, 0, -0.115801, -1, 0.0585535, 0, 1, 0.564709,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.501064,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.238157,-99) , 
12, 0, 0, -5.30872e-05, 5.65743e-06, 8.39115e-06, 0, 0, 0, 0, 0, 0, -0.0290919, 11, -0.02759, 0, 0, 0.455972,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.871141, 0, 0, 0.533523,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 5937.53, 0, -1, 0.074963,-99) , 
12, 0, 0, -0.000350156, -0.00038899, 0.000379163, 0, 0, 0, 0, 0, 0, -0.145492, 11, -0.100115, 0, 0, 0.492256,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.126779);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.0469575, 1, 1, 0.671659,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.614144, 0, -1, 0.481375,-99) , 
12, 0, 0, -4.09913e-05, -5.92956e-05, 6.44007e-05, 0, 0, 0, 0, 0, 0, -0.102255, 11, 0.0663643, 0, 0, 0.494681,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.929678, 0, -1, 0.23199,-99) , 
12, 0, 0, -0.000290797, -0.000336277, 0.000327168, 0, 0, 0, 0, 0, 0, -0.138952, 11, -0.0776003, 0, 0, 0.457562,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.171535);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.547823,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.425627,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.74324, 0, 0, 0.533492,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.0910702, 0, -1, 0.376296,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.571311, 0, 0, 0.520109,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 7072.22, 0, -1, 0.136443,-99) , 
12, 0, 0, -0.000287544, -0.000328938, 0.000318503, 0, 0, 0, 0, 0, 0, -0.118164, 11, -0.082727, 0, 0, 0.485296,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.131596);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.695171,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.457971,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2487.91, 0, 0, 0.603657,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.508795,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.362931,-99) , 
12, 0, 0, 0, 1.78023e-05, -1.31725e-05, 0, 0, 0, 0, 0, 0, -0.00534073, 11, -0.00729901, 0, 0, 0.484317,-99) , 
12, 0, 0, -2.76379e-05, -3.59175e-05, 4.06189e-05, 0, 0, 0, 0, 0, 0, -0.0701569, 11, 0.0415557, 0, 0, 0.493975,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 6154.66, 0, -1, 0.137869,-99) , 
12, 0, 0, -0.000255762, -0.000287672, 0.000279729, 0, 0, 0, 0, 0, 0, -0.107972, 11, -0.0742004, 0, 0, 0.464738,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.144519);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.554924,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.453051,-99) , 
12, 0, 0, -4.92581e-05, -7.20421e-05, 7.30149e-05, 0, 0, 0, 0, 0, 0, -0.0773637, 11, 0.0207484, 0, 0, 0.473294,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.883031, 0, -1, 0.286856,-99) , 
12, 0, 0, -0.000119027, -0.000151794, 0.000148833, 0, 0, 0, 0, 0, 0, -0.09255, 11, -0.0513384, 0, 0, 0.460501,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
12, 0, 0, -0.000229453, -0.000274823, 0.000265335, 0, 0, 0, 0, 0, 0, -0.10873, 11, -0.113006, 0, 0, 0.448018,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.132127);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.577429,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.482705,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.991481, 0, 0, 0.515405,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.532233,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.431417,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0910697, 0, 0, 0.452012,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.913974, 0, 0, 0.491873,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 5965.93, 0, -1, 0.0913947,-99) , 
12, 0, 0, -0.000207253, -0.000239605, 0.000228842, 0, 0, 0, 0, 0, 0, -0.0633362, 11, -0.0675033, 0, 0, 0.470795,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.113688);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.543406,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.483326,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1085.24, 0, 0, 0.52008,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.0910702, 0, -1, 0.434132,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.742642, 0, 0, 0.506511,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 5729.04, 0, -1, 0.165596,-99) , 
12, 0, 0, -0.000180892, -0.000212891, 0.0002031, 0, 0, 0, 0, 0, 0, -0.0589719, 11, -0.0573031, 0, 0, 0.485347,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.131793);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.544861,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.461588,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 2.14186, 1, 0, 0.526274,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.535919,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.443692,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 1.71388, 1, 0, 0.475662,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 2.85048, 1, 0, 0.50451,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.561392,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0193754,-99) , 
12, 0, 0, -0.00250439, -0.0025933, 0.00253743, 0, 0, 0, 0, 0, 0, -0.113012, 11, 0.00377081, 0, 0, 0.30456,-99) , 
12, 0, 0, -0.000186101, -0.000201131, 0.000191498, 0, 0, 0, 0, 0, 0, -0.0310978, 11, -0.0437313, 0, 0, 0.486213,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0852739);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.526059,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.4866,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 6852.34, 1, 0, 0.501479,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.358718,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.314314, 0, 0, 0.497374,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.564482,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0808024,-99) , 
12, 0, 0, -0.00239078, -0.00254449, 0.00247203, 0, 0, 0, 0, 0, 0, -0.0571927, 11, 0.0470792, 0, 0, 0.310823,-99) , 
12, 0, 0, -0.000184357, -0.000201687, 0.000191359, 0, 0, 0, 0, 0, 0, -0.0289377, 11, -0.0439002, 0, 0, 0.480398,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0724559);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.550829,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.494938,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0.0475899, 1, 0, 0.507788,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.319716,-99) , 
12, 0, 0, -4.23229e-05, -4.49681e-05, 4.6175e-05, 0, 0, 0, 0, 0, 0, -0.0351748, 11, -0.0181351, 0, 0, 0.500342,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
12, 0, 0, -0.000189596, -0.000208174, 0.000200384, 0, 0, 0, 0, 0, 0, -0.0551947, 11, -0.0645729, 0, 0, 0.485622,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0882975);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 16342.8, 0, 1, 0.521554,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.405846,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.357146, 0, 0, 0.517465,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.552257,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.401341,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0.332007, 1, 0, 0.474933,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.131527,-99) , 
12, 0, 0, 0, 9.69972e-05, -1.95691e-05, 0, 0, 0, 0, 0, 0, -0.481064, 11, -0.0494549, 0, 0, 0.306374,-99) , 
12, 0, 0, -0.000201612, -0.000211197, 0.000203576, 0, 0, 0, 0, 0, 0, -0.0452856, 11, -0.043737, 0, 0, 0.495956,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.151152);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.562129,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.391272,-99) , 
12, 0, 0, 0, 5.90873e-05, -3.5974e-05, 0, 0, 0, 0, 0, 0, -0.0841257, 11, -0.0312917, 0, 0, 0.516319,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.502473,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.177449,-99) , 
12, 0, 0, 0, -0.000267933, 0.000185451, 0, 0, 0, 0, 0, 0, 0.220813, 11, -0.155568, 0, 0, 0.46591,-99) , 
12, 0, 0, 2.13457e-05, 1.41065e-05, -1.32573e-05, 0, 0, 0, 0, 0, 0, -0.0106526, 11, -0.0033272, 0, 0, 0.498395,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 4932.05, 0, -1, 0.317011,-99) , 
12, 0, 0, -0.000178104, -0.000185361, 0.000179197, 0, 0, 0, 0, 0, 0, -0.042753, 11, -0.0378499, 0, 0, 0.478593,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0766194);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.500858,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.304824,-99) , 
12, 0, 0, -9.19368e-06, 9.61228e-06, -1.37837e-06, 0, 0, 0, 0, 0, 0, -0.0385039, 11, -0.0203067, 0, 0, 0.484006,-99) , 
NN(
0, 
0, 
12, 0, 0, 0, -8.71673e-05, 5.5557e-05, 0, 0, 0, 0, 0, 0, 0.106842, -1, -0.033038, 0, -1, 0.441644,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.813212, 0, 0, 0.47624,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.162224,-99) , 
12, 0, 0, -0.000126623, -0.000147533, 0.000140523, 0, 0, 0, 0, 0, 0, -0.037707, 11, -0.0421366, 0, 0, 0.462991,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0980374);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.558484,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2839.2, 1, -1, 0.46303,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 16239.3, 0, 0, 0.466004,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.200674,-99) , 
12, 0, 0, -0.000117903, -0.000140185, 0.00013238, 0, 0, 0, 0, 0, 0, -0.0296224, 11, -0.040746, 0, 0, 0.454627,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0849838);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.52473,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.458737,-99) , 
12, 0, 0, 1.20304e-05, -3.67994e-06, 2.52202e-06, 0, 0, 0, 0, 0, 0, -0.0143194, 11, -0.00406161, 0, 0, 0.497371,-99) , 
NN(
0, 
0, 
12, 0, 0, -2.45217e-05, 5.84037e-07, 2.20406e-06, 0, 0, 0, 0, 0, 0, 0.0127203, -1, -0.00866557, 0, -1, 0.461294,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.871141, 0, 0, 0.486945,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.189056,-99) , 
12, 0, 0, -0.000117215, -0.000139051, 0.00012998, 0, 0, 0, 0, 0, 0, -0.0177609, 11, -0.0443067, 0, 0, 0.477548,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.054251);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.504949,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.272843,-99) , 
12, 0, 0, 0, -5.25456e-05, 3.95092e-05, 0, 0, 0, 0, 0, 0, 0.013625, 11, -0.0410412, 0, 0, 0.492576,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.405901,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3130.62, 1, 0, 0.489292,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.272183,-99) , 
12, 0, 0, -0.00011595, -0.000123523, 0.000116112, 0, 0, 0, 0, 0, 0, -0.00460072, 11, -0.0363869, 0, 0, 0.481597,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0930132);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.507479,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.271592,-99) , 
12, 0, 0, 0.000133518, 8.41397e-05, -9.09516e-05, 0, 0, 0, 0, 0, 0, 0.0328562, 11, -0.0530299, 0, 0, 0.493051,-99) , 
NN(
0, 
0, 
12, 0, 0, -0.00314535, -0.00268735, 0.0028055, 0, 0, 0, 0, 0, 0, -0.62767, -1, -0.0831773, 0, -1, 0.39747,-99) , 
12, 0, 0, 1.73868e-05, 1.54028e-05, -1.60883e-05, 0, 0, 0, 0, 0, 0, 0.0102914, 11, 0.00482926, 1, 0, 0.481656,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.59798,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0502641,-99) , 
12, 0, 0, -0.00255887, -0.00257729, 0.00252422, 0, 0, 0, 0, 0, 0, -0.0393622, 11, 0.036352, 0, 0, 0.318149,-99) , 
12, 0, 0, -0.00010232, -0.000109003, 0.00010387, 0, 0, 0, 0, 0, 0, -0.0159387, 11, -0.0257758, 0, 0, 0.471289,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.114461);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.507594,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.327995,-99) , 
12, 0, 0, 0, -7.91882e-05, 4.79269e-05, 0, 0, 0, 0, 0, 0, 0.116882, 11, -0.0698342, 0, 0, 0.487972,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.535959,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.437443,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 12413.6, 0, 0, 0.450208,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.929832, 1, 0, 0.466367,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.558887,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0190296,-99) , 
12, 0, 0, -0.00253818, -0.00256503, 0.00250927, 0, 0, 0, 0, 0, 0, -0.0197816, 11, 0.00832341, 0, 0, 0.297053,-99) , 
12, 0, 0, -9.2868e-05, -9.85695e-05, 9.38845e-05, 0, 0, 0, 0, 0, 0, -0.0136255, 11, -0.0240464, 0, 0, 0.456906,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.106756);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.508417,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.348849,-99) , 
12, 0, 0, 0.000106346, 1.94596e-05, -2.69989e-05, 0, 0, 0, 0, 0, 0, -0.0472264, 11, -0.03328, 0, 0, 0.487035,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.51398,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.147625,-99) , 
12, 0, 0, -0.000690617, -0.000362385, 0.000432411, 0, 0, 0, 0, 0, 0, 0.0759441, 11, -0.0252221, 0, 0, 0.371051,-99) , 
12, 0, 0, -1.55986e-05, 2.85613e-05, -1.80174e-05, 0, 0, 0, 0, 0, 0, -0.00909404, 11, -0.02613, 0, 0, 0.474432,-99) , 
NN(
0, 
0, 
12, 0, 0, 0, -0.000913298, 0.000807553, 0, 0, 0, 0, 0, 0, -0.177099, -1, -0.136979, 0, -1, 0.388534,-99) , 
12, 0, 0, 0, -1.06184e-05, 9.51947e-06, 0, 0, 0, 0, 0, 0, -0.0105252, 11, -0.00569332, 0, 0, 0.459005,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.102946);
  fForest.push_back( 
NN(
0, 
0, 
12, 0, 0, 0, 3.75624e-06, -2.06215e-06, 0, 0, 0, 0, 0, 0, -0.00726269, -1, 0.00770198, 1, -1, 0.448708,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.051473);
  fForest.push_back( 
NN(
0, 
0, 
12, 0, 0, 0, 3.77116e-06, -2.07035e-06, 0, 0, 0, 0, 0, 0, -0.00729155, -1, 0.00773259, 1, -1, 0.474286,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0506081);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.506862,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.229298,-99) , 
12, 0, 0, 0, -2.94415e-05, 2.68529e-05, 0, 0, 0, 0, 0, 0, -0.0308342, 11, -0.0232551, 0, 0, 0.498355,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.249733,-99) , 
12, 0, 0, 0, 3.63898e-05, -2.43712e-05, 0, 0, 0, 0, 0, 0, -0.030995, 11, -0.0361338, 0, 0, 0.490141,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.403481,-99) , 
12, 0, 0, 0, 3.77491e-06, -2.07241e-06, 0, 0, 0, 0, 0, 0, -0.0072988, 11, 0.00774027, 1, 0, 0.487135,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0493164);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.501211,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.406858,-99) , 
12, 0, 0, 0, 2.83464e-05, -1.98646e-05, 0, 0, 0, 0, 0, 0, -0.0176918, 11, -0.016508, 0, 0, 0.489239,-99) , 
NN(
0, 
0, 
12, 0, 0, 0, -6.40924e-05, 4.32897e-05, 0, 0, 0, 0, 0, 0, 0.0603105, -1, -0.0159658, 0, -1, 0.454268,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.85986, 0, 0, 0.480523,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 3.42865, 0, -1, 0.413047,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8.56396, 1, 0, 0.476864,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0955009);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.5381,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.417508,-99) , 
12, 0, 0, 0.000130402, 9.58653e-05, -8.77646e-05, 0, 0, 0, 0, 0, 0, -0.0868561, 11, -0.0388557, 0, 0, 0.520432,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.529689,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.284636,-99) , 
12, 0, 0, -0.00125448, -0.000868888, 0.000959222, 0, 0, 0, 0, 0, 0, -0.124565, 11, 0.0556067, 0, 0, 0.384495,-99) , 
12, 0, 0, -8.73981e-05, -1.64288e-05, 3.778e-05, 0, 0, 0, 0, 0, 0, -0.0785245, 11, -0.0415602, 0, 0, 0.491786,-99) , 
NN(
0, 
0, 
12, 0, 0, 0, -5.30454e-05, 3.52219e-05, 0, 0, 0, 0, 0, 0, 0.0553644, -1, -0.0562846, 0, -1, 0.462866,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0.237948, 1, 0, 0.473875,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.142498);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.55476,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.408082,-99) , 
12, 0, 0, 0.00036501, 0.000140722, -0.000164102, 0, 0, 0, 0, 0, 0, -0.00467521, 11, -0.0380963, 0, 0, 0.521198,-99) , 
NN(
0, 
0, 
12, 0, 0, -0.000618739, -0.000467653, 0.000489628, 0, 0, 0, 0, 0, 0, -0.080549, -1, -0.0463159, 0, -1, 0.427094,-99) , 
12, 0, 0, -4.68172e-05, -2.02983e-06, 9.20933e-06, 0, 0, 0, 0, 0, 0, 0.00511539, 11, -0.00502769, 0, 0, 0.491742,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.540561,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.453691,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.913915, 0, 0, 0.503658,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.264353,-99) , 
12, 0, 0, 0.000244154, -0.000916899, 0.000798762, 0, 0, 0, 0, 0, 0, -0.216794, 11, -0.0567831, 0, 0, 0.433533,-99) , 
12, 0, 0, 0, 6.3351e-06, -5.66105e-06, 0, 0, 0, 0, 0, 0, 0.00609873, 11, 0.00371589, 1, 0, 0.483864,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0621408);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.586629,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.497528,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0.331507, 1, 0, 0.534376,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.522282,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.47525,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0173469, 0, 0, 0.485841,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 954.844, 0, -1, 0.414453,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.742663, 0, 0, 0.478487,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0910697, 0, 0, 0.482756,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0490467);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.28415, 1, 1, 0.537147,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.517725,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.481139,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.985364, 0, 0, 0.49375,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.0173452, 1, -1, 0.422932,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.699834, 0, 0, 0.48772,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0910697, 0, 0, 0.491494,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0443521);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.52389,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.43544,-99) , 
12, 0, 0, 0, -5.89009e-05, 4.11954e-05, 0, 0, 0, 0, 0, 0, 0.0446451, 11, -0.0302725, 0, 0, 0.510851,-99) , 
NN(
0, 
0, 
12, 0, 0, 0, 2.1071e-05, -1.02771e-05, 0, 0, 0, 0, 0, 0, -0.0523068, -1, -0.0285372, 0, -1, 0.486739,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.929832, 1, 0, 0.497033,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.416357,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.314314, 0, 0, 0.494734,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0404286);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.615164,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.423578,-99) , 
12, 0, 0, 0, 5.55044e-05, -3.14018e-05, 0, 0, 0, 0, 0, 0, -0.145665, 11, -0.0262778, 0, 0, 0.540966,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.504343,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.418374,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 559.864, 0, 0, 0.499684,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.336782,-99) , 
12, 0, 0, 0, -2.48922e-05, 1.64446e-05, 0, 0, 0, 0, 0, 0, 0.0244099, 11, -0.0311829, 0, 0, 0.4944,-99) , 
12, 0, 0, 0, -6.17044e-06, 6.88223e-06, 0, 0, 0, 0, 0, 0, -0.0174473, 11, 0.0114712, 0, 0, 0.497978,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0430685);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.956723, 0, 1, 0.590883,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.422372,-99) , 
12, 0, 0, 0, 3.31997e-05, -1.70726e-05, 0, 0, 0, 0, 0, 0, -0.116902, 11, -0.0293788, 0, 0, 0.540878,-99) , 
NN(
0, 
0, 
12, 0, 0, 0, -1.39877e-05, 6.50607e-06, 0, 0, 0, 0, 0, 0, 0.0345606, -1, -0.0282627, 0, -1, 0.48499,-99) , 
12, 0, 0, 0, -5.77893e-06, 6.85958e-06, 0, 0, 0, 0, 0, 0, -0.0198156, 11, 0.0113144, 0, 0, 0.490049,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0195262);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.472871, 1, 1, 0.546068,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.502165,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.454036,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.705966, 0, 0, 0.498564,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0910697, 0, 0, 0.501511,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.428701,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.314314, 0, 0, 0.499443,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0391125);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.643447,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.503392,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.400762,-99) , 
12, 0, 0, 0, -3.53034e-06, 2.71952e-06, 0, 0, 0, 0, 0, 0, 0.000281763, 11, -0.00282579, 0, 0, 0.498479,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 2.99893, 0, 0, 0.50546,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.540205,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.488306,-99) , 
12, 0, 0, -0.000115407, -0.00011134, 0.000112214, 0, 0, 0, 0, 0, 0, -0.0550646, 11, 0.000211239, 0, 0, 0.509214,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1767.15, 0, -1, 0.472578,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 1.28568, 1, 0, 0.482145,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 2.8558, 1, 0, 0.495504,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0296382);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.595097,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.457806,-99) , 
12, 0, 0, 0, 3.559e-05, -1.89059e-05, 0, 0, 0, 0, 0, 0, -0.115126, 11, -0.00826307, 0, 0, 0.530848,-99) , 
NN(
0, 
0, 
12, 0, 0, 0, -1.42723e-05, 7.25055e-06, 0, 0, 0, 0, 0, 0, 0.0307195, -1, -0.0248675, 0, -1, 0.490289,-99) , 
12, 0, 0, 0, -3.88499e-06, 4.4839e-06, 0, 0, 0, 0, 0, 0, -0.0122415, 11, 0.00743934, 0, 0, 0.493704,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0163919);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.472871, 1, 1, 0.54658,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.501752,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.455328,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.640705, 0, 0, 0.499311,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0910697, 0, 0, 0.502245,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.438836,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.314314, 0, 0, 0.50045,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0129918);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.554651,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.442858, 0, -1, 0.497225,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.182139, 0, 0, 0.49913,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.448243,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.603297, 0, 0, 0.496976,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0190266);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.559343,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.503575,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.403341,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2900.48, 1, 0, 0.500577,-99) , 
12, 0, 0, 0, -1.76424e-06, 2.54197e-06, 0, 0, 0, 0, 0, 0, -0.00985189, 11, 0.0099616, 0, 0, 0.502162,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.451459,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.603297, 0, 0, 0.500018,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0290108);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.472871, 1, 1, 0.539732,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.529583,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.490725,-99) , 
12, 0, 0, 0, -2.97171e-06, 3.88251e-06, 0, 0, 0, 0, 0, 0, -0.0132197, 11, 0.00658771, 0, 0, 0.494791,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0.0910697, 0, 0, 0.497577,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.43928,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.314314, 0, 0, 0.495928,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.065932);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2420.39, 0, 1, 0.518675,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.284829,-99) , 
12, 0, 0, -9.24919e-05, -6.13298e-05, 6.6191e-05, 0, 0, 0, 0, 0, 0, -0.0238774, 11, -0.034669, 0, 0, 0.506876,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.37682,-99) , 
12, 0, 0, 0, -3.19903e-06, 2.62499e-06, 0, 0, 0, 0, 0, 0, -0.00111605, 11, -0.00239794, 0, 0, 0.500924,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0519223);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.95652, 1, 1, 0.524081,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.319983,-99) , 
12, 0, 0, 0, -0.000311876, 0.000279441, 0, 0, 0, 0, 0, 0, -0.126239, 11, -0.0742796, 0, 0, 0.502727,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0.809024, 1, -1, 0.480617,-99) , 
12, 0, 0, 0, -3.80493e-06, 3.6037e-06, 0, 0, 0, 0, 0, 0, -0.0053654, 11, -0.00167553, 1, 0, 0.487514,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0510158);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.569449,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.468953,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 7289.48, 0, 0, 0.538771,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.358652,-99) , 
12, 0, 0, 0, 6.42591e-05, -4.01946e-05, 0, 0, 0, 0, 0, 0, -0.0814857, 11, -0.0627409, 0, 0, 0.514658,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 11584.8, 1, -1, 0.48705,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1767.02, 0, 0, 0.493233,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0325655);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
12, 0, 0, 0, -2.21587e-05, 2.07384e-05, 0, 0, 0, 0, 0, 0, -0.0277221, -1, 0.0198298, 0, 1, 0.509989,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.349432,-99) , 
12, 0, 0, 0, -4.95226e-05, 4.01608e-05, 0, 0, 0, 0, 0, 0, -0.0104032, 11, -0.0394211, 0, 0, 0.50531,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.411209,-99) , 
12, 0, 0, 0, -7.09532e-06, 5.92366e-06, 0, 0, 0, 0, 0, 0, -0.00331973, 11, 0.00959236, 1, 0, 0.502551,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0371712);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.541329,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.496532,-99) , 
12, 0, 0, 0, -3.54444e-05, 2.93152e-05, 0, 0, 0, 0, 0, 0, -0.0135078, 11, 0.0126855, 0, 0, 0.504625,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.373287,-99) , 
12, 0, 0, 0, 1.0804e-05, -7.37216e-06, 0, 0, 0, 0, 0, 0, -0.00842121, 11, -0.0106745, 0, 0, 0.500221,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.362237,-99) , 
12, 0, 0, 0, -7.91731e-06, 6.98816e-06, 0, 0, 0, 0, 0, 0, -0.0068759, 11, -0.0062521, 0, 0, 0.495346,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0363673);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.510951,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.358621,-99) , 
12, 0, 0, 0, 2.1617e-05, -1.50315e-05, 0, 0, 0, 0, 0, 0, -0.0139449, 11, -0.0214688, 0, 0, 0.506503,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.425102,-99) , 
12, 0, 0, 0, -2.71649e-06, 1.61095e-06, 0, 0, 0, 0, 0, 0, 0.00421909, 11, -0.00471432, 0, 0, 0.5038,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.504192,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.416684,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 3.42865, 0, 0, 0.460968,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8.56396, 1, 0, 0.501508,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0183062);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.501784,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.442664,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8.56396, 1, 0, 0.499711,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.502397,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.449452,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 5.68546, 0, 0, 0.470574,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 4.28568, 1, 0, 0.495937,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.450359,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0.399979, 0, 0, 0.493951,-99)    );
   return;
};

// Clean up
inline void ReadBDTF::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}

inline double ReadBDTF::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}
