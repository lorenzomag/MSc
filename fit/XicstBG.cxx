/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "XicstBG.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include <math.h>
#include "TMath.h"

ClassImp(XicstBG);

XicstBG::XicstBG(const char *name, const char *title,
                 RooAbsReal &_m,
                 RooAbsReal &_a,
                 RooAbsReal &_b,
                 RooAbsReal &_power,
                 RooAbsReal &_cutoff) : RooAbsPdf(name, title),
                                        m("m", "m", this, _m),
                                        a("a", "a", this, _a),
                                        b("b", "b", this, _b),
                                        power("power", "power", this, _power),
                                        cutoff("cutoff", "cutoff", this, _cutoff)
{
}

XicstBG::XicstBG(const XicstBG &other, const char *name) : RooAbsPdf(other, name),
                                                           m("m", this, other.m),
                                                           a("a", this, other.a),
                                                           b("b", this, other.b),
                                                           power("power", this, other.power),
                                                           cutoff("cutoff", this, other.cutoff)
{
}

Double_t XicstBG::evaluate() const
{
  double x = m - cutoff; // Shifted mass
  double evaluation = a * (pow(x, power)) + b * x;

  // std::cout << "evaluate called: evaluation is " << evaluation << std::endl;

  if (TMath::IsNaN(evaluation) && m < cutoff)
    evaluation = 0;

  return evaluation;
}

Int_t XicstBG::getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char * /*rangeName*/) const
{
  // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED,
  // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS
  // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
  // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs
  // EXPRESSION MULTIPLE TIMES

  if (matchArgs(allVars, analVars, m))
    return 1;
  return 0;
}

Double_t XicstBG::analyticalIntegral(Int_t code, const char *rangeName) const
{
  // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
  // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
  // BOUNDARIES FOR EACH OBSERVABLE x

  assert(code == 1);
  auto xmin = m.min(rangeName);
  auto xmax = m.max(rangeName);

  // Lambda for definite integral
  auto defIntegral = [&](double x)
  { return ((b * x * (-2 * cutoff + x)) / 2) + (a * pow((-cutoff + x), (1 + power))) / (1 + power); };

  auto int_max = defIntegral(xmax);
  auto int_min = defIntegral(xmin);

  if (TMath::IsNaN(int_min) && xmin < cutoff)
    int_min = 0;

  // indefinite integral
  auto integ = int_max - int_min;

  // std::cout << "XicstBG::analyticalIntegral called: integral between " << xmin << " and " << xmax << " is " << integ << std::endl;
  return integ;
}
