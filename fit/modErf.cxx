/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "modErf.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include <math.h>
#include "TMath.h"

ClassImp(modErf);

modErf::modErf(const char *name, const char *title,
               RooAbsReal &_x,
               RooAbsReal &_cutoff,
               RooAbsReal &_shift,
               RooAbsReal &_shrink) : RooAbsPdf(name, title),
                                      x("x", "x", this, _x),
                                      cutoff("cutoff", "cutoff", this, _cutoff),
                                      shift("shift", "shift", this, _shift),
                                      shrink("shrink", "shrink", this, _shrink)
{
}

modErf::modErf(const modErf &other, const char *name) : RooAbsPdf(other, name),
                                                        x("x", this, other.x),
                                                        cutoff("cutoff", this, other.cutoff),
                                                        shift("shift", this, other.shift),
                                                        shrink("shrink", this, other.shrink)
{
}

Double_t modErf::evaluate() const
{
  // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE
  double m = x - cutoff;
  double shrunk_m = shrink * m;
  double shifted_m = shrunk_m - shift;

  double evaluation = (TMath::Erf(shifted_m) + 1) / 2.0;
  // std::cout << "evaluation " << evaluation << std::endl; //DEBUG
  return evaluation;
}

Int_t modErf::getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char * /*rangeName*/) const
{
  // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED,
  // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS
  // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
  // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs
  // EXPRESSION MULTIPLE TIMES

  if (matchArgs(allVars, analVars, x))
    return 1;
  return 0;
}

Double_t modErf::analyticalIntegral(Int_t code, const char *rangeName) const
{
  // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
  // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
  // BOUNDARIES FOR EACH OBSERVABLE x

  assert(code == 1);
  auto xmin = x.min(rangeName);
  auto xmax = x.max(rangeName);

  // Lambda for indefinite integralF
  auto indefIntegral = [&](double x)
  { return (exp(-1 * pow((cutoff * shrink + shift - shrink * x), 2)) / (shrink * sqrt(M_PI)) + x + (cutoff + shift / shrink - x) * TMath::Erf(cutoff * shrink + shift - shrink * x)) / 2.0; };

  auto int_max = indefIntegral(xmax);
  auto int_min = indefIntegral(xmin);

  // definite integral
  auto integ = int_max - int_min;
/*
  std::cout << "minx     " << xmin << std::endl;
  std::cout << "maxx     " << xmax << std::endl;
  std::cout << "int_minx " << int_min << std::endl;
  std::cout << "int_maxx " << int_max << std::endl;

  std::cout << "integral " << integ << std::endl;
*/ //DEBUG
  return integ;
}
